#ifndef CMOVERESOURCECOMMAND_H
#define CMOVERESOURCECOMMAND_H

#include "IUndoCommand.h"
#include "Editor/CEditorApplication.h"
#include "Editor/ResourceBrowser/CResourceBrowser.h"
#include <Core/GameProject/CResourceEntry.h>

class CMoveResourceCommand : public IUndoCommand
{
    CResourceEntry *mpEntry;
    TString mOldDirPath;
    TString mNewDirPath;
    bool mOldDirAutoGenerated;

public:
    CMoveResourceCommand(CResourceEntry *pEntry, CVirtualDirectory *pNewDir)
        : IUndoCommand("Move Resource")
        , mpEntry(pEntry)
        , mOldDirPath(pEntry->DirectoryPath())
        , mNewDirPath(pNewDir->FullPath())
        , mOldDirAutoGenerated(pEntry->HasFlag(EResEntryFlag::AutoResDir))
    {}

    // note: for redo, it doesn't matter if the new directory was auto-generated, since the
    // purpose of tracking that flag is to detect which resources have been auto-categorized.
    // if this is being called, even if the new directory is auto-generated, it means the
    // user is intentionally placing it here, so it should be treated as a custom directory
    void undo() override { DoMove(mOldDirPath, mOldDirAutoGenerated); }
    void redo() override { DoMove(mNewDirPath, false); }
    bool AffectsCleanState() const override { return false; }

protected:
    void DoMove(const TString& rkPath, bool IsAutoDir)
    {
        TString ResName = mpEntry->CookedAssetPath(true).GetFileName();
        gpEdApp->ResourceBrowser()->ResourceAboutToBeMoved(mpEntry, TO_QSTRING(rkPath + ResName));

        CVirtualDirectory *pOldDir = mpEntry->Directory();
        bool Success = mpEntry->Move(rkPath, IsAutoDir);
        ASSERT(Success); // todo better error handling

        gpEdApp->ResourceBrowser()->ResourceMoved(mpEntry, pOldDir, mpEntry->Name());
    }
};

#endif // CMOVERESOURCECOMMAND_H
